const path =require('path')
require("dotenv").config()
const express =require('express');
const app = express();
const mongoose =require('mongoose');

// mongoose.connect("mongodb://0.0.0.0:27017/library")
mongoose
    .connect(process.env.DATABASE,{
        useNewUrlParser:true,
        useUnifiedTopology:true
    })
    .then(()=>{
        console.log("DB CONNECTED")
    });
const bookSchema =mongoose.Schema({
        name:String,//bookname
        category:String,
        rent:Number //per day
    });
const bookModel =mongoose.model('book',bookSchema); //books

//README
//http://localhost:4000/

//to add data to books collection
app.use(express.json()); //to get body request in correct JSON format
app.post('/key/:key',async(req,res)=>{
    if(req.params.key==1234){//only people with this key can post data to DB
        let data=new bookModel(req.body)
        let result=await data.save()
        res.send(result)
    }
})

//to search for (bookname)
app.get('/books/:bookname',async(req,res)=>{
    const data =await bookModel.find({"name":{$regex:req.params.bookname}})
    res.send(data)
})
//to search for (rent range)
app.get('/books/:least/:max',async(req,res)=>{
    const data =await bookModel.find({"rent":{$gt:req.params.least-1 ,$lt:req.params.max+1}})//to include least and max values i used ,-1 and +1
    res.send(data)
})
//to search for (category and bookname and rent range)
app.get('/books/:categ/:bookname/:least/:max',async(req,res)=>{
    const data =await bookModel.find({"$and":[{"category":req.params.categ},{"name":{$regex:req.params.bookname}},{$gt:req.params.least-1 ,$lt:req.params.max+1}]})
    res.send(data)
})


function getDays(issueDate,returnDate){
//mm/dd/yy
function parseDate(str) {
    var mdy = str.split('/');
    return new Date(mdy[2], mdy[0]-1, mdy[1]);
}
function datediff(first, second) {
    // Take the difference between the dates and divide by milliseconds per day.
    return Math.round((second-first)/(1000*60*60*24));
}
return (datediff(parseDate(issueDate), parseDate(returnDate)))
}

//TRANSACTION model
const transSchema =mongoose.Schema({
        name:String,//bookname
        person:String,
        issued:String, 
        returned:String,
        netRent:Number,
        isReturned:Boolean
    });

const transModel =mongoose.model('trans',transSchema,'trans'); //trans


app.post('/transaction/:bookname/:personname/:m/:d/:y',async(req,res)=>{
    var dateof =req.params.m+"/"+req.params.d+"/"+req.params.y;//string mm/dd/yyyy

    const checkname=await bookModel.find({"name":{$regex:req.params.bookname}}); //GETTING THE BOOK DATA FROM BOOKS LIBRARY
    
    if(checkname.length>0){//IF BOOK EXIST
        const issueExist =await transModel.find({"$and":[{"person":req.params.personname},{"name":{$regex:req.params.bookname}}]})
        if(issueExist.length==0 ||issueExist[0].isReturned==true){//ISSUE BOOK
            let issueAdd = new transModel({name:checkname[0].name,person:req.params.personname,issued:dateof,returned:"not returned",isReturned:false})
            let result = await issueAdd.save()
            res.send(result)
        }
        else if(issueExist.length>0 && issueExist[0].isReturned==false){//RETURN BOOK
            var days= getDays(issueExist[0].issued,dateof)
            var totalRent=checkname[0].rent*days;
            let returnUpdate =await transModel.updateOne({name:checkname[0].name,person:req.params.personname},{$set:{returned:dateof,isReturned:true,netRent:totalRent}});
            res.send(totalRent.toString())//res is in string because restriction to send number as response
        }
    }
    else{
        res.send("book does not exist")
    }
})
//TO GET ALL THE BOOKS THAT HAVE NOT RETURNED YET
app.get('/transaction/:bookname',async(req,res)=>{
    const data =await transModel.find({"$and":[{"isReturned":false},{"name":{$regex:req.params.bookname}}]})
    res.send(data)
})
//TO GET TOTAL RENT GENERATED BY A BOOK BY NAME
app.get('/transaction/totalRent/:bookname',async(req,res)=>{
    const data =await transModel.find({"$and":[{"name":{$regex:req.params.bookname}},{"netRent":{$exists:true}}]})
    // res.send(data)
    var rent =0;
    if(data.length>0){
        data.forEach((item)=>{
            if(item.netRent>0){
                rent +=item.netRent
            }
        })
    }
    res.send(rent.toString()) 
})
//LIST OF BOOKS ISSUED TO THAT PERSON ,(ASSUMING ALL TIME ISSUES)
app.get('/transaction/issue/:personname',async(req,res)=>{
    const data =await transModel.find({"person":req.params.personname})
    res.send(data)
})
//TO GET ALL BOOKS ISSUED BETWEEN TWO DATES
app.get('/transaction/date/:m1/:d1/:y1/-/:m2/:d2/:y2',async(req,res)=>{
    var data = await transModel.find();
    var result =[]
    data.forEach((item)=>{
        function parseDate(str) {
            var mdy = str.split('/');
            return new Date(mdy[2], mdy[0]-1, mdy[1]);
        }
        var str =item.issued
        var lstr =req.params.m1+"/"+req.params.d1+"/"+req.params.y1;
        var rstr =req.params.m2+"/"+req.params.d2+"/"+req.params.y2;
        str =parseDate(str);
        lstr =parseDate(lstr);
        rstr =parseDate(rstr);

        if(str>lstr && str<rstr){
            result.push(item)
        }
    })
    res.send(result)
})


app.listen(4000)

